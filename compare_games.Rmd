---
title: "Predicting BGG Ratings"
author: Phil Henrickson
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: true
---

This notebook is for building predictive models of boardgame ratings.

```{r global seetings, echo=F, warning=F, message=F}

knitr::opts_chunk$set(echo = F,
                      dev="png",
                      fig.width = 8,
                      fig.height = 8)

options(knitr.duplicate.label = "allow")

options(scipen=999)

```

```{r load and set packages, warning=F, message=F, include=FALSE, results = 'hide'}

source("load_packages.R")
source("theme_phil.R")

```

## Connect to Big Query

### Active Game Rankings

We'll first connect to the most recent day of BGG data that we have in our database. These are the active rankings of games - where they stand in the BGG database as of the most recent load, which I usually update once a week.

```{r connect to big query}

library(bigrquery)

# get project credentials
PROJECT_ID <- "gcp-analytics-326219"
BUCKET_NAME <- "test-bucket"


# establish connection
bigquerycon<-dbConnect(
        bigrquery::bigquery(),
        project = PROJECT_ID,
        dataset = "bgg"
)

```

```{r get active games table}

# query table
active_games<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT * FROM bgg.active_games_daily')


```


### Additional Game Information

We also want to pull down other tables containing the information that we know about games.

```{r query tables with game information}

# general game info
games_info<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT * FROM bgg.active_games_info')

# game categories
game_categories<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT 
                              a.game_id,
                              b.category_id,
                              b.category
                              FROM bgg.game_categories a
                               LEFT JOIN bgg.category_ids b 
                               ON a.category_id = b.category_id')

# game mechanics
game_mechanics<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT 
                              a.game_id,
                              b.mechanic_id,
                              b.mechanic
                              FROM bgg.game_mechanics a
                               LEFT JOIN bgg.mechanic_ids b 
                               ON a.mechanic_id = b.mechanic_id')

# game publishers
game_publishers<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT 
                              a.game_id,
                              b.publisher_id,
                              b.publisher
                              FROM bgg.game_publishers a
                               LEFT JOIN bgg.publisher_ids b 
                               ON a.publisher_id = b.publisher_id')

# game designers
game_designers<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT 
                              a.game_id,
                              b.designer_id,
                              b.designer
                              FROM bgg.game_designers a
                               LEFT JOIN bgg.designer_ids b 
                               ON a.designer_id = b.designer_id')

# game artists
game_artists<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT 
                              a.game_id,
                              b.artist_id,
                              b.artist
                              FROM bgg.game_artists a
                               LEFT JOIN bgg.artist_ids b 
                               ON a.artist_id = b.artist_id')

```

## Which Games are Similar to Each Other?

We can use some unsupervised techniques to identify games that are similar to each other. We'll start by building a dataset with the information available to use about a game at the time of its release: playtime, player count, categories, mechanics, and designers. We'll use all games published before 2021.

### Build Dataset

```{r prep a recipe for pca}

# specify an end year
end_train_year = 2021

# combine all
games_full<-active_games %>%
  filter(usersrated >= 100) %>% # set a minimum threshold
  select(timestamp, game_id, name, average, baverage, usersrated) %>%
  left_join(., games_info %>% # join game info
              select(game_id, yearpublished, avgweight, minage, minplayers, maxplayers, playingtime),
            by = c("game_id")) %>%
  filter(yearpublished < end_train_year) %>% # use games prior to 2020 as our training set
  left_join(., game_categories %>% # join categories
              mutate(category = gsub("\\)", "", gsub("\\(", "", category))) %>%
              mutate(category = tolower(paste("cat", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", category))), sep="_"))) %>%
              mutate(has_category = 1) %>%
              select(-category_id) %>%
              pivot_wider(names_from = c("category"),
                          values_from = c("has_category"),
                          id_cols = c("game_id"),
                          names_sep = "_",
                          values_fn = min,
                          values_fill = 0),
            by = c("game_id")) %>%
  left_join(., game_mechanics %>% # join mechanics
              mutate(mechanic = tolower(paste("mech", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", mechanic))), sep="_"))) %>%
              mutate(has_mechanic = 1) %>%
              select(-mechanic_id) %>%
              pivot_wider(names_from = c("mechanic"),
                          values_from = c("has_mechanic"),
                          id_cols = c("game_id"),
                          names_sep = "_",
                          values_fn = min,
                          values_fill = 0),
            by = c("game_id")) %>%
      left_join(., game_designers %>% # join designers
              mutate(designer = gsub("\\)", "", gsub("\\(", "", designer))) %>%
              mutate(designer = tolower(paste("des", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", designer))), sep="_"))) %>%
              mutate(has_designer = 1) %>%
              select(-designer_id) %>%
              pivot_wider(names_from = c("designer"),
                          values_from = c("has_designer"),
                          id_cols = c("game_id"),
                          names_sep = "_",
                          values_fn = min,
                          values_fill = 0),
            by = c("game_id")) 

# %>%
#         left_join(., game_publishers %>% # join publishers
#               mutate(publisher = gsub("\\)", "", gsub("\\(", "", publisher))) %>%
#               mutate(publisher = tolower(paste("pub", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", publisher))), sep="_"))) %>%
#               mutate(has_publisher = 1) %>%
#               select(-publisher_id) %>%
#               pivot_wider(names_from = c("publisher"),
#                           values_from = c("has_publisher"),
#                           id_cols = c("game_id"),
#                           names_sep = "_",
#                           values_fn = min,
#                           values_fill = 0),
#             by = c("game_id")) 

# %>%
#       left_join(., game_designers %>% # join designers
#               mutate(designer = gsub("\\)", "", gsub("\\(", "", designer))) %>%
#               mutate(designer = tolower(paste("des", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", designer))), sep="_"))) %>%
#               mutate(has_designer = 1) %>%
#               select(-designer_id) %>%
#               pivot_wider(names_from = c("designer"),
#                           values_from = c("has_designer"),
#                           id_cols = c("game_id"),
#                           names_sep = "_",
#                           values_fn = min,
#                           values_fill = 0),
#             by = c("game_id"))

        # left_join(., game_artists %>% # join artists
        #       mutate(artist = gsub("\\)", "", gsub("\\(", "", artist))) %>%
        #       mutate(artist = tolower(paste("artist", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", artist))), sep="_"))) %>%
        #       mutate(has_artist = 1) %>%
        #       select(-artist_id) %>%
        #       pivot_wider(names_from = c("artist"),
        #                   values_from = c("has_artist"),
        #                   id_cols = c("game_id"),
        #                   names_sep = "_",
        #                   values_fn = min,
        #                   values_fill = 0),
        #     by = c("game_id"))

```

### Build Recipes

```{r normlize for pca and k means}

# create recipe to normalize
recipe_pca<- recipe(~., x = games_full) %>%
  update_role(timestamp,
        usersrated,
        game_id,
        name,
        baverage,
        average,
        new_role = "id") %>%
  step_mutate(record_id = row_number(), role ="ID") %>%
  step_filter(!is.na(yearpublished)) %>%
  step_filter(
          cat_collectible_components !=1 &
                  cat_expansion_for_basegame != 1) %>% # remove specific categories that count expansions
  # step_mutate(yearpublished = case_when(yearpublished <= 1950 ~ 1950,
  #                                  TRUE ~ as.numeric(yearpublished))) %>% # truncate yearpublished
  step_impute_median(avgweight,
              minplayers,
              maxplayers,
              playingtime,
              minage) %>% # medianimpute numeric predictors
  step_mutate(minplayers = case_when(minplayers < 1 ~ 1,
                           #    minplayers > 10 ~ 10,
                               TRUE ~ minplayers),
        maxplayers = case_when(maxplayers < 1 ~ minplayers,
                    #           maxplayers > 20 ~ 20,
                               TRUE ~ maxplayers)) %>% # truncate player range
  step_mutate(time_per_player = playingtime/ maxplayers) %>% # make time per player variable
  step_mutate_at(starts_with("cat_"),
           fn = ~ replace_na(., 0)) %>%
  step_mutate_at(starts_with("mech_"),
           fn = ~ replace_na(., 0)) %>%
  step_mutate_at(starts_with("des_"),
           fn = ~ replace_na(., 0)) %>%
  step_mutate(number_mechanics = rowSums(across(starts_with("mech_"))),
              number_categories = rowSums(across(starts_with("cat_"))),
              number_designers = rowSums(across(starts_with("des_")))) %>%
  step_log(playingtime,
     time_per_player,
     offset = 1) %>%
  step_zv(all_predictors()) %>%
  step_normalize(., all_numeric_predictors()) %>%
  step_nzv(all_predictors(),
     freq_cut = 200/1) %>%
  check_missing(all_numeric_predictors())

# use the recipe
norm_games_full<-recipe_pca %>%
        prep(games_full, strings_as_factors=F) %>%
        bake(games_full)

```

### PCA

What features should we include when running PCA? It depends on what we're trying to do. If we're looking for games that are similar to each other mechanically without respect to theme, then we shouldn't include dimensions about the game's theme/category. If we're trying to find games that are the most similar to each other on every dimension, then we will include categories.

We'll set up two datasets, one with categories and one without, in order to fit a PCA to both.

```{r nest and set up for pca, warning=F}

# create two datasets
nested_data<-norm_games_full %>%
  mutate(dataset = "info, categories, mechanics, designers",
         time_period = "published before 2020") %>%
  nest(-dataset, -time_period) %>%
  bind_rows(., norm_games_full %>%
              mutate(dataset = "info, mechanics and designers",
                     time_period = "published before 2020") %>%
              select(-starts_with("cat_"),
                     -number_categories) %>%
              nest(-dataset, -time_period))

```

Now fit pca on each of these.

```{r fit pca to each of these datasets}

pca_map<-nested_data %>%
  mutate(pca = map(data, ~ prcomp(.x %>% 
                                    select(-record_id) %>%
                                    select(-one_of(summary(recipe_pca) %>% filter(role == 'id') %>% pull(variable))) %>% # remove id vars
                                    select(where(is.numeric)), # keep only numeric
                                  center=F, scale = F)))

```

We can inspect the results of each of these.

```{r extract results from running PCA}

# function for contributions of variables
var_coord_func <- function(loadings, comp.sdev){
  loadings*comp.sdev
}

# cos2 of each individual
getdistance <- function(ind_row, center, scale){
  return(sum(((ind_row-center)/scale)^2))
}

# get cos2
cos2 <- function(ind.coord, d2){return(ind.coord^2/d2)}

# examine pca using functions
pca_map<-pca_map %>%
  mutate(summary_pca = map(pca, ~ summary(.x))) %>%
  mutate(scree_pca = map(pca, ~ fviz_eig(.x))) %>%
  mutate(var_coord = map(pca, ~ round(t(apply(.x$rotation, 1, var_coord_func, .x$sdev)), 3) %>%
                           as.data.frame() %>%
                           rownames_to_column("feature") %>%
                           mutate(feature = abbreviate(feature, minlength=15)))) %>%
  mutate(viz_var = map(pca, ~ fviz_pca_var(.x,
                                           col.var = "contrib", # Color by contributions to the PC
                                           repel = TRUE     # Avoid text overlapping
                                           ))) %>%
  mutate(pca_rotation = map(pca, ~ .x$x)) %>%
  mutate(pca_rotation_names = map2(.x = pca_rotation,
                                   .y = data,
                                   ~ cbind.data.frame(.x, .y))) %>%
  mutate(viz_ind = map(pca_rotation_names, ~ 
                         ggplot(., aes(x=PC1, 
                                       y=PC2,
                                       label = name))+
                         geom_jitter(alpha=0.65,
                                     height=0.4)+
                         theme_phil()+
                         geom_text(check_overlap = T,
                                   size=2)+
                         xlab("Principal Component 1")+
                         ylab("Principal Component 2")+
                         # coord_cartesian(xlim = c(-13, 7),
                         #                 ylim = c(-6, 8))+
                         geom_vline(xintercept=0, linetype = 'dotted')+
                         geom_hline(yintercept=0, linetype = 'dotted')))

```

Plot variable contributions

```{r visualize variable contributions, warning=F}

# with categories
pca_map[1,]$viz_var

# without categories
pca_map[2,]$viz_var

```
Plot individual games

```{r games, fig.height=4}

# with categories
pca_map[1,]$viz_ind

# without
pca_map[2,]$viz_ind

```
We can now get the distance matrix to calculate nearest nearest neighbors.

```{r map}

# get distance matrix
pca_map<-pca_map %>%
  mutate(names = map(data, ~ .x %>%
                       select(game_id, name) %>%
                       mutate(record_id = as.character(row_number())))) %>%
  mutate(dist_matrix = map(pca_rotation, ~ dist(.x, method="euclidean") %>%
                             as.matrix() %>%
                             as.data.frame())) %>%
  mutate(dist = map(dist_matrix, ~ .x %>%
                             rownames_to_column("record_id") %>%
                             gather('closest','dist',-record_id) %>%
                             filter(dist > 0) %>%
                             filter(!is.na(dist)) %>% 
                             group_by(record_id) %>% 
                             arrange(dist) %>% 
                             slice_min(dist, n=150, with_ties = T) %>%
                             mutate(dist_rank=row_number()))) %>%
  mutate(neighbors = map2(dist, names,
                      ~ left_join(.x, .y, by = c("record_id")) %>%
                        select(record_id, game_id, name, closest, dist, dist_rank) %>%
                        left_join(., .y %>%
                                    rename(neighbor_record_id = record_id,
                                           neighbor_game_id = game_id,
                                           neighbor_name = name),
                                  by = c("closest" = "neighbor_record_id")))) 

```

#### Nearest Neighbors

Let's join this up with the games info so we can then filter on rating, that sort of thing.

```{r lets get the neighbors, warning=F}

neighbors<-pca_map %>%
  select(dataset, neighbors) %>% 
  unnest() %>%
  mutate(similarity = 100*1/(1+ sqrt(dist))) %>%
  select(dataset, game_id, name, neighbor_game_id, neighbor_name, similarity, dist, dist_rank) %>%
  left_join(., active_games %>%
              rename(neighbor_game_id = game_id,
                     neighbor_name = name))

# most similar inside the top 5000
neighbors %>%
  filter(dataset == 'info, categories, mechanics, designers') %>%
  filter(rank < 5000) %>%
  arrange(dist) %>%
  head(50) %>%
  mutate(game_id = as.character(game_id),
         neighbor_game_id = as.character(neighbor_game_id),
         yearpublished = as.character(yearpublished)) %>%
  select(dataset, game_id, name, neighbor_game_id, neighbor_name, similarity, dist, yearpublished, rank, average, baverage) %>%
  mutate_if(is.numeric, round, 2) %>%
  flextable() %>%
  autofit()


```

Examine distributions of similarity.

```{r examine distribution of distance between neighbors}


neighbors %>%
  filter(dataset == 'info, categories, mechanics, designers') %>%
  ggplot(., aes(x=dist))+
  geom_histogram(bins = 50)+
  theme_phil()

neighbors %>%
  filter(dataset == 'info, categories, mechanics, designers') %>%
  ggplot(., aes(x=log(dist)))+
  geom_histogram(bins = 50)+
  theme_phil()


neighbors %>%
  filter(dataset == 'info, categories, mechanics, designers') %>%
  ggplot(., aes(x=similarity))+
  geom_histogram(bins = 100)+
  theme_phil()

neighbors %>%
  filter(dataset == 'info, categories, mechanics, designers') %>%
  ggplot(., aes(x=log(similarity)))+
  geom_histogram(bins = 100)+
  theme_phil()

```
```{r}

# quantiles
quantiles<-neighbors %>%
  #filter(dataset == 'info, categories, mechanics, designers') %>%
  filter(dataset == 'info, mechanics and designers') %>%
  summarize(dist = rev(quantile(log(similarity), probs = seq(0, 1, .1)))) %>%
  cbind.data.frame(., quantile= seq(0, 1, .1)) %>%
  mutate(similarity_score = (1-quantile) * 100) %>%
  mutate_if(is.numeric, round, 3) %>%
  mutate(assign_score = dplyr::lag(similarity_score, 1))

quantiles

# create a function
similarity_func<-function(neighbors_dat, quantiles_dat) {
  
  neighbors %>%
   #filter(dataset == 'info, categories, mechanics, designers') %>%
    filter(dataset == 'info, mechanics and designers') %>%
    mutate(dist = log(similarity)) %>%
    mutate(similarity_score = case_when(dist >
                                          (quantiles %>%
                                          filter(quantile == 0.1) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.1) %>%
                                          pull(assign_score)
                                          ),
                                        dist > 
                                        (quantiles %>%
                                          filter(quantile == 0.2) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.2) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                                        (quantiles %>%
                                          filter(quantile == 0.3) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.3) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                                        (quantiles %>%
                                          filter(quantile == 0.4) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.4) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                                        (quantiles %>%
                                          filter(quantile == 0.6) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.6) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                                        (quantiles %>%
                                          filter(quantile == 0.6) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.6) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                                        (quantiles %>%
                                          filter(quantile == 0.7) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.7) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                                        (quantiles %>%
                                          filter(quantile == 0.8) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.8) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                                        (quantiles %>%
                                          filter(quantile == 0.9) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 0.9) %>%
                                          pull(assign_score)
                                          ),
                                        dist> 
                             (quantiles %>%
                                          filter(quantile == 1) %>%
                                          pull(dist)) ~  (quantiles %>%
                                          filter(quantile == 1) %>%
                                          pull(assign_score)),
                             TRUE ~ 0)) %>%
    select(game_id, name, neighbor_name, similarity_score, similarity, dist, dist_rank) %>%
    filter(grepl("Merchants & Marauders", name))
           
}

```

If we're recommending games, we're trying to balance both similarity and quality. Let's set up a function for computing a recommendation score that balances these two.

```{r recommend games}

rec_score_func<-function(neighbors_data,
                         min_rank,
                         similarity_weight,
                         n_rec ) {
  
  neighbors_data %>%
    filter(rank <= min_rank) %>%
    group_by(dataset) %>%
    mutate(rec_score = similarity_weight*similarity + baverage*(1-similarity_weight)) %>%
    group_by(dataset, game_id) %>%
    arrange(desc(rec_score)) %>%
    mutate(rec_rank = row_number()) %>%
    select(dataset, game_id, name, neighbor_game_id, neighbor_name, rec_score, rec_rank, similarity, dist_rank) %>%
    group_by(dataset) %>%
    arrange(rec_rank) %>%
    filter(rec_rank <= n_rec)
  
}

# use the function
rec_score_func(
  neighbors,
  5000,
  0.4,
  5) %>%
  filter(name == 'Troyes') %>%
  mutate_if(is.numeric, round, 2)

rec_score_func(
  neighbors,
  5000,
  0.4,
  5) %>%
  filter(game_id == 9609) %>%
#  filter(dataset == 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2)

rec_score_func(
  neighbors,
  5000,
  0.5,
  5) %>%
  filter(name == 'Tiny Towns') %>%
  mutate_if(is.numeric, round, 2)

rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(name == 'Star Wars: Legion') %>%
  filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2)

rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(name == 'Star Wars: Imperial Assault') %>%
  filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2)

rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(game_id == 131357) %>%
  filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2)


rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(grepl("Quacks of Quedlinburg", name)) %>%
  filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2)

 rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(game_id == 281655) %>%
 # filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2) %>%
  rename(compare_by = dataset) %>%
  select(compare_by, name, neighbor_name, rec_score, rec_rank) %>%
   arrange(compare_by, rec_rank) %>%
   flextable() %>%
   autofit()
 
 rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(grepl("Quacks of Quedlinburg", name)) %>%
  filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2)
 
  rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(name == 'Concordia') %>%
 # filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2) %>%
      rename(compare_by = dataset) %>%
  select(compare_by, name, neighbor_name, rec_score, rec_rank) %>%
   arrange(compare_by, rec_rank) %>%
   flextable() %>%
   autofit()


 rec_score_func(
  neighbors,
  5000,
  0.5,
  10) %>%
  filter(game_id == 16387) %>%
 # filter(dataset != 'info, categories, mechanics, designers') %>%
  mutate_if(is.numeric, round, 2) %>%
  rename(compare_by = dataset) %>%
  select(compare_by, name, neighbor_name, rec_score, rec_rank) %>%
   arrange(compare_by, rec_rank) %>%
   flextable() %>%
   autofit()



```
  
Recommendations

```{r run all games through the recommendation func}

recommend<- rec_score_func(
  neighbors,
  5000,
  0.5,
  10)

# dataset of recommendations
recommend %>%
  left_join(., active_games %>%
              select(game_id, rank, baverage)) %>%
  arrange(dataset, rank) 

```

  
We can use this to identify comparables and recommendations for games released in 2021-2022.

```{r create dataset for new games}

# combine all
new_games_full<-active_games %>%
 # filter(usersrated >= 100) %>% # set a minimum threshold
  select(timestamp, game_id, name, average, baverage, usersrated) %>%
  left_join(., games_info %>% # join game info
              select(game_id, yearpublished, avgweight, minage, minplayers, maxplayers, playingtime),
            by = c("game_id")) %>%
  filter(yearpublished >= end_train_year) %>% # use games prior to 2020 as our training set
  left_join(., game_categories %>% # join categories
              mutate(category = gsub("\\)", "", gsub("\\(", "", category))) %>%
              mutate(category = tolower(paste("cat", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", category))), sep="_"))) %>%
              mutate(has_category = 1) %>%
              select(-category_id) %>%
              pivot_wider(names_from = c("category"),
                          values_from = c("has_category"),
                          id_cols = c("game_id"),
                          names_sep = "_",
                          values_fn = min,
                          values_fill = 0),
            by = c("game_id")) %>%
  left_join(., game_mechanics %>% # join mechanics
              mutate(mechanic = tolower(paste("mech", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", mechanic))), sep="_"))) %>%
              mutate(has_mechanic = 1) %>%
              select(-mechanic_id) %>%
              pivot_wider(names_from = c("mechanic"),
                          values_from = c("has_mechanic"),
                          id_cols = c("game_id"),
                          names_sep = "_",
                          values_fn = min,
                          values_fill = 0),
            by = c("game_id")) %>%
      left_join(., game_designers %>% # join designers
              mutate(designer = gsub("\\)", "", gsub("\\(", "", designer))) %>%
              mutate(designer = tolower(paste("des", gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", designer))), sep="_"))) %>%
              mutate(has_designer = 1) %>%
              select(-designer_id) %>%
              pivot_wider(names_from = c("designer"),
                          values_from = c("has_designer"),
                          id_cols = c("game_id"),
                          names_sep = "_",
                          values_fn = min,
                          values_fill = 0),
            by = c("game_id")) 

# bake
norm_new_games_full<- recipe_pca %>%
  prep(games_full, strings_as_factors = F) %>%
  bake(new_games_full)

```

Now run this through our PCA.

```{r predict with pca, warning=F}


data_combined<-bind_rows(norm_games_full %>%
                           mutate(time_period = "published before 2021") %>%
                         norm_new_games_full %>%
                           mutate(time_period = "published after 2021")) %>%
  as.data.frame() %>%
  nest()


pca_predict<-pca_map %>%
  mutate(training = "published before 2021") %>%
  select(dataset, training, pca) %>%
  
  mutate(pca_rotation_names = map(data_combined,
                                  predict(pca, newdata = .x)))

pca_combined<-norm_new_games_full %>%
  select(-record_id) %>%
  select(-one_of(summary(recipe_pca) %>% 
                   filter(role == 'id') %>% pull(variable))) %>% # remove id vars
  select(where(is.numeric)) %>% # keep only numeric
  predict(pca$pca[[1]], newdata=.) %>%
  cbind.data.frame(., norm_new_games_full) %>%
  mutate(dataset = "games_published_after_2020") %>%
  nest(-dataset) %>%
  rename(pca_rotation_names=data) %>%
  bind_rows(.,
            pca %>% 
              mutate(dataset="games_published_before_2020") %>%
              select(dataset, pca_rotation_names))


norm_new_games_full %>%
  mutate(dataset = "info, categories, mechanics, designers",
         time_period = "published after 2020") %>%
  bind_rows(., norm_new_games_full %>%
              mutate(dataset = "info, mechanics and designers",
                     time_period = "published after 2020")) %>%
  nest(-dataset, -time_period) %>%
  left_join(., 
            pca_map %>%
              select(dataset, pca)) %>%
  mutate(pca_rotation = map2(data, pca, ~ predict(.y, newdata = .x))) %>%
  bind_rows(.,
            pca_map %>%
              select(dataset, time_period, data, pca, pca_rotation)


```


```{r predict and combine, warning=F, fig.height=4}

pca_combined<-norm_new_games_full %>%
  select(-record_id) %>%
  select(-one_of(summary(recipe_pca) %>% filter(role == 'id') %>% pull(variable))) %>% # remove id vars
  select(where(is.numeric)) %>% # keep only numeric
  predict(pca$pca[[1]], newdata=.) %>%
  cbind.data.frame(., norm_new_games_full) %>%
  mutate(dataset = "games_published_after_2020") %>%
  nest(-dataset) %>%
  rename(pca_rotation_names=data) %>%
  bind_rows(.,
            pca %>% 
              mutate(dataset="games_published_before_2020") %>%
              select(dataset, pca_rotation_names))

# Plot
pca_combined %>%
  unnest() %>%
 # filter(dataset=='games_published_after_2020') %>%
  ggplot(., aes(x=PC1, 
                y=PC2,
                color=dataset,
                label = name))+
   geom_jitter(alpha=0.5,
               height=0.4)+
   theme_phil()+
   geom_text(check_overlap=T)+
   # coord_cartesian(xlim = c(-21, 9),
   #                 ylim = c(-8, 10))+
   geom_vline(xintercept=0, linetype = 'dotted')+
   geom_hline(yintercept=0, linetype = 'dotted')+
  guides(label = "none",
         color = "none")+
  scale_color_manual(values = c("blue", "grey20"))

```

Let's look at some new games to identify their closest comparables.

```{r look at new games, warning=F}

dist_combined<-dist(pca_combined %>%
  unnest() %>%
  select(starts_with("PC")),
  method = "euclidean")

# first, extract CompanyNames from our id data
game_names<-pca_combined %>%
  unnest() %>%
  select(dataset, game_id, name)

# convert to df
mat<-dist_combined%>% 
  as.matrix() %>%
  as.data.frame()

# reCompanyName
rownames(mat)<-game_names$game_id
colnames(mat)<-game_names$game_id

# next, extract CompanyIDs for discovery wi and discovery others
new_games<-pca_combined %>%
  unnest() %>%
  filter(dataset == 'games_published_after_2020') %>%
  pull(game_id)

# trained_games<-pca_combined %>%
#   filter(dataset == 'Discovery_WI') %>%
#   pull(CompanyID)

```

```{r new neighbors}

# now get n nearest neighbors
new_neighbors<-mat %>%
  rownames_to_column("game_id") %>%
  gather('closest','dist',-game_id) %>%
  filter(dist > 0) %>%
  filter(!is.na(dist)) %>% 
  group_by(game_id) %>% 
  arrange(dist) %>% 
  slice_min(dist, n=15, with_ties = T) %>%
  mutate(dist_rank=row_number()) %>%
  left_join(., game_names %>%
              mutate(game_id = as.character(game_id)),
              by = c("game_id")) %>%
  select(game_id, name, closest, dist, dist_rank) %>%
  left_join(., game_names %>%
              mutate(game_id = as.character(game_id)) %>%
              rename(neighbor_id = game_id,
                     neighbor_name = name),
            by = c("closest" = "neighbor_id")) %>%
  select(game_id, name, closest, neighbor_name, dist, dist_rank) %>%
  rename(neighbor_id = closest)

```

Closest Mechanical Neighbors

```{r look at games}

new_neighbors %>%
  filter(grepl("On Mars", name))

new_neighbors %>%
  filter(grepl("Gloomhaven", name))

new_neighbors %>%
  filter(grepl("Lisboa", name))

new_neighbors %>%
  filter(grepl("Great Western Trail", name))

```



#### Nearest Mechanical Neighbors

Should we include categories in finding neighbors? It depends on what we're trying to do. If we're looking for games that are similar to each other mechanically without respect to theme, then we shouldn't include dimensions about the game's theme/category. If we're trying to find games that are the most similar to each other on every dimension, then we will include categories.

```{r update the recipe without categories}

recipe_pca_no_categories<-recipe_pca %>%
  step_rm(starts_with("cat_"))
          
# update recipe and bake
norm_games_no_categories<-recipe_pca_no_categories %>%
        prep(games_full, strings_as_factors=F) %>%
        bake(games_full)

```

```{r fit a pca again, warning=F}

# now fit a pca once more
mechanical_pca_map<-norm_games_no_categories %>%
  nest() %>%
  mutate(pca = map(data, ~ prcomp(.x %>% 
                                    select(-record_id) %>%
                                    select(-one_of(summary(recipe_pca) %>% filter(role == 'id') %>% pull(variable))) %>% # remove id vars
                                    select(where(is.numeric)), # keep only numeric
                                  center=F, scale = F)))

```

Inspect results of PCA

```{r extract results from running PCA}

# examine pca using functions
mechanical_pca_map<-mechanical_pca_map %>%
  mutate(summary_pca = map(pca, ~ summary(.x))) %>%
  mutate(scree_pca = map(pca, ~ fviz_eig(.x))) %>%
  mutate(var_coord = map(pca, ~ round(t(apply(.x$rotation, 1, var_coord_func, .x$sdev)), 3) %>%
                           as.data.frame() %>%
                           rownames_to_column("feature") %>%
                           mutate(feature = abbreviate(feature, minlength=15)))) %>%
  mutate(viz_var = map(pca, ~ fviz_pca_var(.x,
                                           col.var = "contrib", # Color by contributions to the PC
                                           repel = TRUE     # Avoid text overlapping
                                           ))) %>%
  mutate(viz_ind = map(pca, ~ fviz_pca_ind(.x,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)))    # Avoid text overlapping


```


```{r visualize variable contributions}

mechanical_pca_map$viz_var

```

Plot games

```{r games, fig.height=4}

## plot
mechanical_pca<-mechanical_pca_map %>%
  mutate(pca_rotation = map(pca, ~ .x$x)) %>%
  mutate(pca_rotation_names = map2(.x = pca_rotation,
                                   .y = data,
                                   ~ cbind.data.frame(.x, .y))) %>%
  mutate(viz_ind = map(pca_rotation_names, ~ 
                         ggplot(., aes(x=PC1, 
                                       y=PC2,
                                       label = name))+
                         geom_jitter(alpha=0.65,
                                     height=0.4)+
                         theme_phil()+
                         geom_text(check_overlap = T,
                                   size=2)+
                         xlab("Principal Component 1")+
                         ylab("Principal Component 2")+
                         # coord_cartesian(xlim = c(-13, 7),
                         #                 ylim = c(-6, 8))+
                         geom_vline(xintercept=0, linetype = 'dotted')+
                         geom_hline(yintercept=0, linetype = 'dotted')))

mechanical_pca$viz_ind

```


```{r get nearest neighbors}

# first, extract names from our id data
mechanical_names<-mechanical_pca$data[[1]] %>%
  select(game_id, name)

mechanical_dist_matrix<-dist(mechanical_pca$pca[[1]]$x, method = "euclidean")

# convert to df
mechanical_mat<-mechanical_dist_matrix %>% 
  as.matrix() %>%
  as.data.frame()

# rename
rownames(mechanical_mat)<-mechanical_names$game_id
colnames(mechanical_mat)<-mechanical_names$game_id

# now get n nearest neighbors
mechnical_neighbors<-mechanical_mat %>%
  rownames_to_column("game_id") %>%
  gather('closest','dist',-game_id) %>%
  filter(dist > 0) %>%
  filter(!is.na(dist)) %>% 
  group_by(game_id) %>% 
  arrange(dist) %>% 
  slice_min(dist, n=15, with_ties = T) %>%
  mutate(dist_rank=row_number()) %>%
  left_join(., mechanical_names %>%
              mutate(game_id = as.character(game_id)),
              by = c("game_id")) %>%
  select(game_id, name, closest, dist, dist_rank) %>%
  left_join(., mechanical_names %>%
              mutate(game_id = as.character(game_id)) %>%
              rename(neighbor_id = game_id,
                     neighbor_name = name),
            by = c("closest" = "neighbor_id")) %>%
  select(game_id, name, closest, neighbor_name, dist, dist_rank) %>%
  rename(neighbor_id = closest)

mechanical_neighbors

```

We can now look up any game to identify it's nearest neighbors.

```{r look up any game to identify its nearest neighbor}

# x wing
mechanical_neighbors %>%
  filter(game_id == 	252328)

# concordia
mechanical_neighbors %>%
  filter(game_id == 	124361)

# nemesis
mechanical_neighbors %>%
  filter(game_id == 	167355)

# agricola
mechanical_neighbors %>%
  filter(game_id == 	31260)

# fury of dracula
mechanical_neighbors %>%
  filter(game_id == 	181279)

# quacks
mechanical_neighbors %>%
  filter(grepl("Quacks", name))

# el grande
mechanical_neighbors %>%
  filter(grepl("El Grande", name))

# imperial assault
mechanical_neighbors %>%
  filter(grepl("Imperial Assault", name))

# xia
mechanical_neighbors %>%
  filter(grepl("Xia:", name))

# terra mystica
mechanical_neighbors %>%
  filter(grepl("Terra Mystica", name))

# xia
mechanical_neighbors %>%
  filter(grepl("Undaunted", name))

```

Generate a similarity score

```{r rescale}

mechanical_neighbors<-mechanical_neighbors %>%
  ungroup() %>%
  #  mutate(similarity = 100*1/(1+ sqrt(dist))) %>%
  mutate(similarity = 100*1/(1+ sqrt(dist))) 

mechanical_neighbors %>%
  ggplot(., aes(x=similarity))+
  geom_histogram(bins=50)+
  theme_phil()

```
##### New Games Comparables

We can use this to identify the nearest neighbors for games released in 2020-2022.

```{r create dataset for new games}

# bake
norm_new_games_no_categories<- recipe_pca_no_categories %>%
  prep(games_full, strings_as_factors = F) %>%
  bake(new_games_full)

```


Now run this through our PCA.

```{r predict and combine, warning=F, fig.height=4}

mechanical_pca_combined<-norm_new_games_no_categories %>%
  select(-record_id) %>%
  select(-one_of(summary(recipe_pca) %>% filter(role == 'id') %>% pull(variable))) %>% # remove id vars
  select(where(is.numeric)) %>% # keep only numeric
  predict(pca$pca[[1]], newdata=.) %>%
  cbind.data.frame(., norm_new_games_full) %>%
  mutate(dataset = "games_published_after_2020") %>%
  nest(-dataset) %>%
  rename(pca_rotation_names=data) %>%
  bind_rows(.,
            pca %>% 
              mutate(dataset="games_published_before_2020") %>%
              select(dataset, pca_rotation_names))

# Plot
pca_combined %>%
  unnest() %>%
 # filter(dataset=='games_published_after_2020') %>%
  ggplot(., aes(x=PC1, 
                y=PC2,
                color=dataset,
                label = name))+
   geom_jitter(alpha=0.5,
               height=0.4)+
   theme_phil()+
   geom_text(check_overlap=T)+
   # coord_cartesian(xlim = c(-21, 9),
   #                 ylim = c(-8, 10))+
   geom_vline(xintercept=0, linetype = 'dotted')+
   geom_hline(yintercept=0, linetype = 'dotted')+
  guides(label = "none",
         color = "none")+
  scale_color_manual(values = c("blue", "grey20"))

```

Let's look at some new games to identify their closest comparables.

```{r look at new games, warning=F}

dist_combined<-dist(pca_combined %>%
  unnest() %>%
  select(starts_with("PC")),
  method = "euclidean")

# first, extract CompanyNames from our id data
game_names<-pca_combined %>%
  unnest() %>%
  select(dataset, game_id, name)

# convert to df
mat<-dist_combined%>% 
  as.matrix() %>%
  as.data.frame()

# reCompanyName
rownames(mat)<-game_names$game_id
colnames(mat)<-game_names$game_id

# next, extract CompanyIDs for discovery wi and discovery others
new_games<-pca_combined %>%
  unnest() %>%
  filter(dataset == 'games_published_after_2020') %>%
  pull(game_id)

# trained_games<-pca_combined %>%
#   filter(dataset == 'Discovery_WI') %>%
#   pull(CompanyID)

```

```{r new neighbors}

# now get n nearest neighbors
new_neighbors<-mat %>%
  rownames_to_column("game_id") %>%
  gather('closest','dist',-game_id) %>%
  filter(dist > 0) %>%
  filter(!is.na(dist)) %>% 
  group_by(game_id) %>% 
  arrange(dist) %>% 
  slice_min(dist, n=15, with_ties = T) %>%
  mutate(dist_rank=row_number()) %>%
  left_join(., game_names %>%
              mutate(game_id = as.character(game_id)),
              by = c("game_id")) %>%
  select(game_id, name, closest, dist, dist_rank) %>%
  left_join(., game_names %>%
              mutate(game_id = as.character(game_id)) %>%
              rename(neighbor_id = game_id,
                     neighbor_name = name),
            by = c("closest" = "neighbor_id")) %>%
  select(game_id, name, closest, neighbor_name, dist, dist_rank) %>%
  rename(neighbor_id = closest)

```

Closest Mechanical Neighbors

```{r look at games}

new_neighbors %>%
  filter(grepl("On Mars", name))

new_neighbors %>%
  filter(grepl("Gloomhaven", name))

new_neighbors %>%
  filter(grepl("Lisboa", name))

new_neighbors %>%
  filter(grepl("Great Western Trail", name))

```


